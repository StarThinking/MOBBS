// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "StorageServer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::storage;
using namespace std;

struct MigratingParams
{
	Migrater* m_migrater;
	string m_eid;
	int m_from;
	int m_to;
};

void* migrating(void* argv)
{
	MigratingParams* mp = (MigratingParams*)argv;
	mp->m_migrater->finish_migration(mp->m_eid);
	delete(mp);
	
	return NULL;
}

class StorageServiceHandler : virtual public StorageServiceIf {
 public:
  StorageServiceHandler(Migrater* migrater) {
    // Your initialization goes here
		m_migrater = migrater;
  }

  void do_migration(const std::string& eid, const int32_t from, const int32_t to) {
    // Your implementation goes here
    printf("do_migration: %s %d %d\n", eid.c_str(), from, to);
    MigratingParams* mp = new MigratingParams;
    mp->m_migrater = m_migrater;
    mp->m_eid = eid;
    mp->m_from = from;
    mp->m_to = to;
    pthread_t pid;
    pthread_create(&pid, NULL, migrating, mp);
  }

	Migrater* m_migrater;

};

StorageServer::StorageServer(Migrater* migrater)
{
	m_migrater = migrater;
}

void* listening(void* argv)
{
	cout << "Storage server start" << endl;
	StorageServer* ss = (StorageServer*)argv;
	((TSimpleServer*)ss->m_server)->serve();
	
	return NULL;
}

void StorageServer::start() {
  int port = 9090;
  shared_ptr<StorageServiceHandler> handler(new StorageServiceHandler(m_migrater));
  shared_ptr<TProcessor> processor(new StorageServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  m_server = new TSimpleServer(processor, serverTransport, transportFactory, protocolFactory);
  pthread_t pid;
	pthread_create(&pid, NULL, listening, this);
}

void StorageServer::stop()
{
	((TSimpleServer*)m_server)->stop();
	delete((TSimpleServer*)m_server);
}

