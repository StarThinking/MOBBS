// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "ClientServer.h"
#include "gen-cpp/ClientService.h"
#include "monitor_service/MonitorService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::librbd;
using namespace std;

class ClientServiceHandler : virtual public ClientServiceIf {
 public:
  ClientServiceHandler(ClientServer* client_server) {
    // Your initialization goes here
		m_client_server = client_server;
		m_ictx = client_server->m_ictx;
  }

  void begin_migration(const std::string& eid, const int32_t from, const int32_t to) {
    // Your implementation goes here
    LockProcessParams* lpp = new LockProcessParams;
    lpp->m_ictx = m_ictx;
    lpp->m_eid = eid;
    lpp->m_from = from;
    lpp->m_to = to;

		pthread_mutex_lock(&m_client_server->m_mutex);
		m_client_server->m_queue.push(lpp);
		pthread_cond_signal(&m_client_server->m_cond);
		pthread_mutex_unlock(&m_client_server->m_mutex);
  }

  void finish_migration(const std::string& eid, const int32_t from, const int32_t to) {
    // Your implementation goes here
 	m_ictx->m_mapper->set_pool(eid, to);
	m_ictx->m_mapper->release_extent(eid);

	pthread_mutex_lock(&m_client_server->m_mutex);
	m_client_server->m_cur_locks --;
	pthread_cond_signal(&m_client_server->m_cond);
	pthread_mutex_unlock(&m_client_server->m_mutex);

	char my_log2[100];
	sprintf(my_log2, "finish migration: eid %s from %d to %d", eid.c_str(), from, to);
	take_log(my_log2);
  }

	ClientServer* m_client_server;
  ImageCtx* m_ictx;
	
};


void* lock_process(void* argv);
void* listenning(void* argv);
void* dispatching(void* argv);


void* lock_process(void* argv)
{
	LockProcessParams* lpp = (LockProcessParams*)argv;
	ImageCtx* ictx = lpp->m_ictx;
	string eid = lpp->m_eid;
	int from = lpp->m_from;
	int to = lpp->m_to;

	char my_log1[100];
	sprintf(my_log1, "migration request: eid %s from %d to %d", eid.c_str(), from, to);
	take_log(my_log1);

	ictx->m_mapper->lock_extent(eid);

	char my_log2[100];
	sprintf(my_log2, "extent locked: eid %s", eid.c_str());
	take_log(my_log2);

  boost::shared_ptr<TTransport> socket(new TSocket("10.0.0.10", 9090));
	boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
	boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
	monitor::MonitorServiceClient client(protocol);
	try
	{
		transport->open();
		client.finish_lock(eid);
		transport->close();
	}
	catch(TException& tx)
	{
		take_log("Failed to connect to monitor after lock");
	}

	delete(lpp);
	return NULL;
}

ClientServer::ClientServer(ImageCtx* ictx)
{
	m_ictx = ictx;
	m_thread_pool = new MobbsUtil::ThreadPool(1);
	m_listening = false;
	m_max_locks = 1;
	m_cur_locks = 0;
}

ClientServer::~ClientServer()
{
	delete(m_thread_pool);
}

void ClientServer::start()
{
  	int port = THRIFT_PORT;
  	shared_ptr<ClientServiceHandler> handler(new ClientServiceHandler(this));
  	shared_ptr<TProcessor> processor(new ClientServiceProcessor(handler));
  	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  	m_server = new TSimpleServer(processor, serverTransport, transportFactory, protocolFactory);
	m_listening = true;
	int ret = pthread_create(&m_pid, NULL, listenning, this);
	if(ret != 0) 
	{
		std::cout << "fail to start client server" << std::endl;
	}
	pthread_t pid;
	pthread_create(&pid, NULL, dispatching, this);
}

void* listenning(void* argv) {
  ClientServer* cs = (ClientServer*)argv;

  take_log("Client server started");

  ((TSimpleServer*)cs->m_server)->serve();

  take_log("Client server stopped");

  return NULL;
}

void* dispatching(void* argv)
{
	ClientServer* cs = (ClientServer*)argv;
	while(cs->m_listening)
	{
		pthread_mutex_lock(&cs->m_mutex);
		while(cs->m_queue.empty() || cs->m_max_locks <= cs->m_cur_locks)
		{
			pthread_cond_wait(&cs->m_cond, &cs->m_mutex);
			if(!cs->m_listening)
			{
				pthread_mutex_unlock(&cs->m_mutex);
				return NULL;
			}
		}

		cs->m_cur_locks ++;
		LockProcessParams* lpp = cs->m_queue.front();
		cs->m_queue.pop();
		pthread_mutex_unlock(&cs->m_mutex);

		cs->m_thread_pool->create_thread(lock_process, lpp);
	}
	return NULL;
}

void ClientServer::stop()
{
	m_listening = false;
	((TSimpleServer*)m_server)->stop();
  	delete((TSimpleServer*)m_server);

		pthread_mutex_lock(&m_mutex);
		pthread_cond_signal(&m_cond);
		pthread_mutex_unlock(&m_mutex);
}
